// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.3.1
// LVGL version: 8.3.6
// Project name: PHC_RET6

#include "ui.h"
#include "pid.h"
#include "stdio.h"
#include "FreeRTOS.h"
#include "cmsis_os2.h"
#include "queue.h"

#include "task.h"
extern pid_handler Upright_ring_pid,Speed_loop_pid,Steering_ring_pid,TSL1401_pid;
extern osMessageQueueId_t Motor_isEnable_queueHandle;
extern osMessageQueueId_t target_speed_QueueHandle,target_speed_difference_QueueHandle;
//输入现在想调试的环
pid_handler *pid=&TSL1401_pid;
//输入kp，ki，kd的步进值
float kp_step=0.1;
float ki_step=0.1;
float kd_step=0.1;


char sbuf[30];



//电机启动
void Motor_switch_checked(lv_event_t * e)
{
    uint8_t isEnable=1;
    //速度环I清空
    Speed_loop_pid.sum_deviation=0;
	xQueueOverwrite(Motor_isEnable_queueHandle, &isEnable);
    //速度环目标清空
    // float target_speed=0;
    // xQueueSend(target_speed_QueueHandle, &target_speed, 0);
    //转向环I清空
    Steering_ring_pid.sum_deviation=0;
    
}

void Motor_switch_unchecked(lv_event_t * e)
{
	uint8_t isEnable=0;
	xQueueOverwrite(Motor_isEnable_queueHandle, &isEnable);
}



void zero(lv_event_t * e)
{
	pid->kp=0;
    pid->ki=0;
    pid->kd=0;
    sprintf(sbuf,"P:%.2f",pid->kp);
    lv_label_set_text(ui_P, sbuf);
    sprintf(sbuf,"I:%.2f",pid->ki);
    lv_label_set_text(ui_I, sbuf);
    sprintf(sbuf,"D:%.2f",pid->kd);
    lv_label_set_text(ui_D, sbuf);

}

void mainScreen_init(lv_event_t * e)
{
    lv_group_remove_all_objs(lv_group_get_default());
    
	lv_group_add_obj(lv_group_get_default(), ui_batBar);
	lv_group_add_obj(lv_group_get_default(), ui_toControlButton);
	lv_group_add_obj(lv_group_get_default(), ui_toPidButton);
	lv_group_add_obj(lv_group_get_default(), ui_toTsl1401Button);
}


float target_speed_difference=0;
  float target_speed;
  extern osMessageQueueId_t target_speed_QueueHandle,target_speed_difference_QueueHandle;
void Forwardandbackward_Left(lv_event_t * e)
{
	target_speed+=0.02;
    xQueueOverwrite(target_speed_QueueHandle, &target_speed);
    sprintf(sbuf,"%.2f",target_speed);
    lv_label_set_text(ui_Forward_and_backward, sbuf);
}

void Forwardandbackward_Right(lv_event_t * e)
{
	target_speed-=0.02;
    xQueueOverwrite(target_speed_QueueHandle, &target_speed);
    sprintf(sbuf,"%.2f",target_speed);
    lv_label_set_text(ui_Forward_and_backward, sbuf);
}

void Leftturnandrightturn_Left(lv_event_t * e)
{
	target_speed_difference+=10;
    xQueueOverwrite(target_speed_difference_QueueHandle, &target_speed_difference);
    sprintf(sbuf,"%.1f",target_speed_difference);
    lv_label_set_text(ui_Left_turn_and_right_turn, sbuf);
}

void Leftturnandrightturn_Right(lv_event_t * e)
{
	target_speed_difference-=10;
    xQueueOverwrite(target_speed_difference_QueueHandle, &target_speed_difference);
    sprintf(sbuf,"%.1f",target_speed_difference);
    lv_label_set_text(ui_Left_turn_and_right_turn, sbuf);
}

void MotorControlScreen_load_start(lv_event_t * e)
{
	lv_group_remove_all_objs(lv_group_get_default());
	lv_group_add_obj(lv_group_get_default(), ui_Forward_and_backward);
	lv_group_add_obj(lv_group_get_default(), ui_Left_turn_and_right_turn);
	lv_group_add_obj(lv_group_get_default(), ui_backButton1);
	lv_group_add_obj(lv_group_get_default(), ui_MotorSwitch1);
    //更新电机开关状态
    uint8_t isEnable;
    xQueuePeek(Motor_isEnable_queueHandle, &isEnable, 0);
    if(isEnable)
    {
        lv_obj_add_state(ui_MotorSwitch1, LV_STATE_CHECKED);
    }
    else
    {
        lv_obj_clear_state(ui_MotorSwitch1, LV_STATE_CHECKED);
    }
}
extern osThreadId_t TSL1401ScreenHandle;
void TSL1401Screen_load_start(lv_event_t * e)
{
	lv_group_remove_all_objs(lv_group_get_default());
	lv_group_add_obj(lv_group_get_default(), ui_tsl1401Screen);
    //初始化前进速度
    float target_speed=0.1f;
    xQueueSend(target_speed_QueueHandle, &target_speed, 0);
    Motor_switch_checked(NULL);
    
    osThreadResume(TSL1401ScreenHandle);
}

void TSL1401Screen_unload_start(lv_event_t * e)
{
	osThreadSuspend(TSL1401ScreenHandle);
    Motor_switch_unchecked(NULL);
    //速度环目标清空
    float target_speed=0;
    xQueueSend(target_speed_QueueHandle, &target_speed, 0);
    //转向环目标清空
    float target_speed_difference=0;
    xQueueSend(target_speed_difference_QueueHandle, &target_speed_difference, 0);
}

void P_Left(lv_event_t * e)
{
    pid->kp+=kp_step;
	sprintf(sbuf,"P:%.2f",pid->kp);
    lv_label_set_text(ui_P, sbuf);
}

void P_Right(lv_event_t * e)
{
	pid->kp-=kp_step;
	sprintf(sbuf,"P:%.2f",pid->kp);
    lv_label_set_text(ui_P, sbuf);
}

void I_Left(lv_event_t * e)
{
	pid->ki+=ki_step;
	sprintf(sbuf,"I:%.2f",pid->ki);
    lv_label_set_text(ui_I, sbuf);
}

void I_Right(lv_event_t * e)
{
	pid->ki-=ki_step;
	sprintf(sbuf,"I:%.2f",pid->ki);
    lv_label_set_text(ui_I, sbuf);
}

void D_Left(lv_event_t * e)
{
	pid->kd+=kd_step;
    sprintf(sbuf,"D:%.2f",pid->kd);
    lv_label_set_text(ui_D, sbuf);
}

void D_Right(lv_event_t * e)
{
	pid->kd-=kd_step;
    sprintf(sbuf,"D:%.2f",pid->kd);
    lv_label_set_text(ui_D, sbuf);
}
void PIDControlScreen_Task(void *argument){
  char text[30];
  while (1)
  {
    //读取现在想调试的环的输入显示在ui_PIDinput上
    sprintf(text,"IN:%.2f",pid->deviation);
    lv_label_set_text(ui_PIDinput, text);
    osDelay(100);
  }
  
  
  
}
TaskHandle_t PIDControlScreen_Task_handler;
void pidControlScreen_load_start(lv_event_t * e)
{
	lv_group_remove_all_objs(lv_group_get_default());
	lv_group_add_obj(lv_group_get_default(), ui_MotorSwitch);
	lv_group_add_obj(lv_group_get_default(), ui_P);
    lv_group_add_obj(lv_group_get_default(), ui_I);
    lv_group_add_obj(lv_group_get_default(), ui_D);
    
    lv_group_add_obj(lv_group_get_default(), ui_backButton);
    lv_group_add_obj(lv_group_get_default(), ui_zeroButton);
    
    sprintf(sbuf,"P:%.2f",pid->kp);
    lv_label_set_text(ui_P, sbuf);
    sprintf(sbuf,"I:%.2f",pid->ki);
    lv_label_set_text(ui_I, sbuf);
    sprintf(sbuf,"D:%.2f",pid->kd);
    lv_label_set_text(ui_D, sbuf);
    //更新电机开关状态
    uint8_t isEnable;
    xQueuePeek(Motor_isEnable_queueHandle, &isEnable, 0);
    if(isEnable)
    {
        lv_obj_add_state(ui_MotorSwitch, LV_STATE_CHECKED);
    }
    else
    {
        lv_obj_clear_state(ui_MotorSwitch, LV_STATE_CHECKED);
    }
    xTaskCreate(PIDControlScreen_Task, "PIDControlScreen_Task", 256, NULL, 1, &PIDControlScreen_Task_handler);
}

void pidControlScreen_unload_start(lv_event_t * e)
{
	vTaskDelete(PIDControlScreen_Task_handler);
}
